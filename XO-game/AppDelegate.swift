//
//  AppDelegate.swift
//  XO-game
//
//  Created by Evgeny Kireev on 25/02/2019.
//  Copyright © 2019 plasmon. All rights reserved.
//

import UIKit


/*
 Практическое задание
 
 1. Задание на паттерн State.
 В этом практическом задании вы будете продолжать проект с игрой в крестики-нолики, который делали на уроке. Задача в том, чтобы добавить еще один режим — игра против компьютера. Режим можно выбрать из главного меню, на экране которого должно быть две кнопки: «Игра против компьютера» и «Игра с двумя игроками». Напишите алгоритм, по которому компьютер будет делать ходы. Самый простой вариант — компьютер рандомно ставит отметку в любой свободной клетке.
 (* Дополнительно: можете усложнить этот алгоритм — в интернете есть готовые решения и советы.)
 Добавьте новый state — ход компьютера. Аналогично примерам из урока сделайте переключение состояния со state игрока на state компьютера при выполнении шагов в игре.
2. Второе задание на паттерн State.
 Примечание: возможно, задания 2 и 3 вы решите делать вместе, поэтому прочтите их оба, прежде чем приступать к выполнению.
 Изменим правила игры: теперь игроки ходят не по очереди, а сначала первый игрок указывает 5 клеток, в которые он ставит крестик, затем второй игрок указывает 5 клеток, куда он ставит нолик. Затем игра должна показать расстановку крестиков и ноликов в последовательности крестик — нолик — крестик — нолик — ... Иными словами, правила игры такие же, как раньше, только теперь каждый игрок должен вслепую заранее указать все свои 5 ходов. Если отметка одного игрока при этом накладывается на отметку другого (они же не знали ходы друг друга, так что такое возможно), то она сначала стирает предыдущую отметку и затем ставится в эту клетку. Когда пройдена последовательность ходов, игра определяет победителя.
 Реализуйте такое поведение для игры между двумя живыми игроками, добавив еще одно состояние — состояние хода игрока, в котором игрок ставит все 5 отметок. Затем добавьте еще состояние исполнения игры. В нем игра должна последовательно показать ходы игроков, как если бы они шли в обычной игре в крестики-нолики. Затем должен определиться победитель (для этого можно использовать написанный на уроке код).
 3. Задание на паттерн Command.
 Ход игрока представьте в виде команды. Recievers (получатели) у нас уже есть — это объект доски и ее view. Подумайте, кто будет являться invoker’ом. Подсказка: для него лучше создать отдельный объект. Команду инициализируйте с информацией об игроке, позиции и доске. В команду добавьте метод execute(), в котором будет обращение к receiver’ам: добавить отметку на доску, отрисовать ее. PlayerInputState измените так, чтобы когда юзер тапает на клетку, он вызывал добавление команды invoker’у. Когда все ходы расставлены, state исполнения игры сообщает invoker’у, что нужно исполнить все команды, и таким образом партия игры будет разыграна.
 4. * Необязательное задание на паттерн Prototype. Исследуйте свои имеющиеся проекты — где можно применить паттерн «прототип». Если можно вместо повторной инициализации копии объекта использовать прототип, то добавьте этому объекту поддержку протокола Copying и реализуйте паттерн.
 5. * Дополнительное (необязательное) задание на паттерн State. Сделайте приложение, которое будет отображать светофор с тремя состояниями: «горит зеленый», «горит красный» и «горит желтый свет». Все три состояния сделайте разными объектами, поддерживающими один протокол State. Состояния должны сменять друг друга с задержкой.
 6. ** Дополнительное (необязательное) задание на паттерн Command. Реализуйте паттерн «команда» для одной из задач, описанных в этой методичке в разделе «Паттерн Command. Применение на практике».

 
 */




@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
}

